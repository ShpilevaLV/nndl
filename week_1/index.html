// В dashboard.js добавьте эти функции:

// Update overall statistics
function updateOverallStats() {
    const totalPassengers = titanicData.length;
    const survivors = titanicData.filter(p => p.Survived === 1).length;
    const deaths = totalPassengers - survivors;
    
    const deathRate = totalPassengers > 0 ? ((deaths / totalPassengers) * 100).toFixed(1) : '--';
    const survivalRate = totalPassengers > 0 ? ((survivors / totalPassengers) * 100).toFixed(1) : '--';
    
    document.getElementById('overallTotalPassengers').textContent = totalPassengers;
    document.getElementById('overallDeathRate').textContent = `${deathRate}%`;
    document.getElementById('overallSurvivalRate').textContent = `${survivalRate}%`;
}

// Update top groups with better formatting
function updateTopGroups() {
    const highestElem = document.getElementById('highestDeathGroup');
    const lowestElem = document.getElementById('lowestDeathGroup');
    
    if (!highestElem || !lowestElem) return;
    
    const groups = [];
    
    // Analyze gender groups
    ['male', 'female'].forEach(gender => {
        const group = titanicData.filter(p => p.Sex === gender);
        if (group.length > 0) {
            const deathRate = (group.filter(p => p.Survived === 0).length / group.length * 100).toFixed(1);
            groups.push({
                name: gender.charAt(0).toUpperCase() + gender.slice(1),
                deathRate: parseFloat(deathRate),
                size: group.length
            });
        }
    });
    
    // Analyze class groups
    [1, 2, 3].forEach(pclass => {
        const group = titanicData.filter(p => p.Pclass === pclass);
        if (group.length > 0) {
            const deathRate = (group.filter(p => p.Survived === 0).length / group.length * 100).toFixed(1);
            groups.push({
                name: `Class ${pclass}`,
                deathRate: parseFloat(deathRate),
                size: group.length
            });
        }
    });
    
    if (groups.length > 0) {
        const highest = groups.reduce((max, g) => g.deathRate > max.deathRate ? g : max, groups[0]);
        const lowest = groups.reduce((min, g) => g.deathRate < min.deathRate ? g : min, groups[0]);
        
        // Format with better styling
        highestElem.innerHTML = `
            <span class="d-block">${highest.name}</span>
            <span class="text-danger fw-bold">${highest.deathRate}% death rate</span>
        `;
        
        lowestElem.innerHTML = `
            <span class="d-block">${lowest.name}</span>
            <span class="text-success fw-bold">${lowest.deathRate}% death rate</span>
        `;
    }
}

// В функции parseCSVData добавьте вызов updateOverallStats после успешной загрузки данных:
async function parseCSVData(csvText, source) {
    return new Promise((resolve, reject) => {
        Papa.parse(csvText, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: function(results) {
                try {
                    titanicData = results.data.filter(p => p.PassengerId);
                    console.log(`Successfully parsed ${titanicData.length} passenger records from ${source}`);
                    
                    // Data cleaning and feature engineering
                    titanicData = titanicData.map(passenger => {
                        // Create derived features
                        passenger.FamilySize = (passenger.SibSp || 0) + (passenger.Parch || 0) + 1;
                        passenger.IsAlone = passenger.FamilySize === 1;
                        passenger.AgeGroup = getAgeGroup(passenger.Age);
                        
                        // Ensure numeric fields are properly typed
                        passenger.Pclass = parseInt(passenger.Pclass) || 3;
                        passenger.Age = passenger.Age ? parseFloat(passenger.Age) : null;
                        passenger.Fare = passenger.Fare ? parseFloat(passenger.Fare) : null;
                        passenger.SibSp = parseInt(passenger.SibSp) || 0;
                        passenger.Parch = parseInt(passenger.Parch) || 0;
                        passenger.Survived = parseInt(passenger.Survived) || 0;
                        
                        return passenger;
                    });
                    
                    filteredData = [...titanicData];
                    
                    // Initialize dashboard
                    updateDataStatus(source);
                    updateQuickStats();
                    updateDataPreview();
                    updateTopGroups();
                    updateOverallStats(); // Добавлен вызов
                    createAllCharts();
                    updateCurrentStats();
                    updateConclusion(); // Auto-generate conclusion
                    
                    // Auto-switch to Insights tab
                    setTimeout(() => {
                        const insightsTab = document.getElementById('insights-tab');
                        if (insightsTab) {
                            insightsTab.click();
                        }
                    }, 800);
                    
                    resolve();
                } catch (error) {
                    reject(new Error('Error processing data: ' + error.message));
                }
            },
            error: function(error) {
                reject(new Error('Error parsing CSV: ' + error.message));
            }
        });
    });
}
